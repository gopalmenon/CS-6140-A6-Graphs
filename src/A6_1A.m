# Return a matrix raised to a power of 2function [new_matrix] = get_matrix_power(input_matrix, power_of_two)  # Base case for recursion  if power_of_two == 1    new_matrix = input_matrix;  else    matrix_half_way =  get_matrix_power(input_matrix, power_of_two/2);    new_matrix = matrix_half_way * matrix_half_way;  endif  end# Iterate random walk for a number of iterationsfunction [final_probability_vector] = do_random_walk(transition_matrix, initial_probability_vector, number_of_iterations)  final_probability_vector = initial_probability_vector;  for iteration_counter = 1:number_of_iterations    final_probability_vector = transition_matrix * final_probability_vector;  endforend# Return the first normalized eigen vector of a matrixfunction [first_normalized_eigen_vector] = get_first_normalized_eigen_vector(input_matrix)    [eigen_vectors, eigen_values] = eig(input_matrix);    first_eigen_vector = eigen_vectors(:,1);  first_normalized_eigen_vector = first_eigen_vector/norm(first_eigen_vector, 2);end# Load transition matrixload ../data/M.dat;# Number of iterationst=1024;# Initial vectorq0 = zeros(size(M)(1),1);q0(1,1) = 1;transition_matrix_power = get_matrix_power(M, t);final_probability_vector_matrix_power = transition_matrix_power * q0final_probability_vector_state_propagation = do_random_walk(M, q0, t)first_normalized_eigen_vector = get_first_normalized_eigen_vector(M)