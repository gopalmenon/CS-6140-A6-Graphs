# Return a matrix raised to a power of 2function [new_matrix] = get_matrix_power(input_matrix, power_of_two)  # Base case for recursion  if power_of_two == 1    new_matrix = input_matrix;  else    matrix_half_way =  get_matrix_power(input_matrix, power_of_two/2);    new_matrix = matrix_half_way * matrix_half_way;  endif  end# Iterate random walk for a number of iterationsfunction [final_probability_vector] = do_random_walk(transition_matrix, initial_probability_vector, number_of_iterations)  final_probability_vector = initial_probability_vector;  for iteration_counter = 1:number_of_iterations    final_probability_vector = transition_matrix * final_probability_vector;  endforend# Return the first normalized eigen vector of a matrixfunction [first_normalized_eigen_vector] = get_first_normalized_eigen_vector(input_matrix)    [eigen_vectors, eigen_values] = eig(input_matrix);    first_eigen_vector = eigen_vectors(:,1);  first_normalized_eigen_vector = first_eigen_vector/norm(first_eigen_vector, 2);end# Return a vector after a burn in period function [post_burn_in_vector] = get_post_burn_in_vector(input_matrix, number_of_iterations, starting_column_value)  # Start with the column value passed in  previous_column_value = starting_column_value;  # At each iteration, select a value proportional to the number of values in the previous column selected  for iteration_counter = 1:number_of_iterations;      # Next column value selected will be equal to the number of non-zero values in the previous column    previous_column_value = numel(find(input_matrix(:, previous_column_value) != 0));    endfor    post_burn_in_vector = zeros(size(input_matrix)(1), 1);  post_burn_in_vector(previous_column_value, 1) = 1;end# Estimate page rank from burn in vector function [burn_in_page_rank] = get_burn_in_page_rank(input_matrix, post_burn_in_vector, number_of_iterations)    previous_vector = post_burn_in_vector;  burn_in_page_rank = zeros(size(input_matrix)(2), 1);  for iteration_counter = 1:number_of_iterations;    next_column_value = numel(find(input_matrix(:, find(previous_vector == 1)) != 0));    previous_vector = zeros(size(input_matrix)(1), 1);    previous_vector(next_column_value, 1) = 1;    burn_in_page_rank(next_column_value, 1) += 1;  endfor    burn_in_page_rank = burn_in_page_rank/norm(burn_in_page_rank, 1);end# Load transition matrixload ../data/M.dat;# Answer 1A# Number of iterationst=1024;# Initial vectorq0 = zeros(size(M)(1),1);q0(1,1) = 1;transition_matrix_power = get_matrix_power(M, t);final_probability_vector_matrix_power = transition_matrix_power * q0final_probability_vector_state_propagation = do_random_walk(M, q0, t)post_burn_in_vector = get_post_burn_in_vector(M, t, 4);burn_in_page_rank = get_burn_in_page_rank(M, post_burn_in_vector, t)first_normalized_eigen_vector = get_first_normalized_eigen_vector(M)